//! BaseTranscript: Fiat-Shamir transcript for prover-verifier communication.
//!
//! Port of C++ `BaseTranscript<Codec_, HashFunction_>` from `transcript/transcript.hpp`.
//! This is the native (non-circuit) specialization.

use bbrs_ecc::curves::bn254::Fr;

use crate::codec::{split_challenge, FieldSerializable};
use crate::manifest::TranscriptManifest;

/// Hash function trait for transcript challenge generation.
pub trait TranscriptHasher {
    fn hash(input: &[Fr]) -> Fr;
}

/// Common transcript class for both prover and verifier.
///
/// Stores data for the current round, generates Fiat-Shamir challenges,
/// and maintains a proof buffer for serialization.
///
/// Port of C++ `BaseTranscript<Codec_, HashFunction_>` specialized for native (non-circuit) mode.
pub struct BaseTranscript<H: TranscriptHasher> {
    // Proof data buffer
    proof_data: Vec<Fr>,

    // Challenge generation state
    is_first_challenge: bool,
    previous_challenge: Fr,
    current_round_data: Vec<Fr>,

    // Proof parsing state
    proof_start: isize,
    num_frs_written: usize,
    num_frs_read: usize,
    round_number: usize,

    // Manifest (debugging tool)
    use_manifest: bool,
    manifest: TranscriptManifest,

    _hasher: std::marker::PhantomData<H>,
}

impl<H: TranscriptHasher> BaseTranscript<H> {
    /// Create a new empty transcript (prover mode).
    pub fn new() -> Self {
        Self {
            proof_data: Vec::new(),
            is_first_challenge: true,
            previous_challenge: Fr::zero(),
            current_round_data: Vec::new(),
            proof_start: 0,
            num_frs_written: 0,
            num_frs_read: 0,
            round_number: 0,
            use_manifest: false,
            manifest: TranscriptManifest::new(),
            _hasher: std::marker::PhantomData,
        }
    }

    /// Create a transcript from proof data (verifier mode).
    pub fn from_proof(proof: &[Fr]) -> Self {
        let mut t = Self::new();
        t.load_proof(proof);
        t
    }

    /// Load proof data (verifier-specific). Appends to existing proof_data.
    pub fn load_proof(&mut self, proof: &[Fr]) {
        self.proof_data.extend_from_slice(proof);
    }

    /// Return the proof data starting at proof_start for num_frs_written elements.
    ///
    /// Useful when two provers share a transcript: calling export_proof at the end
    /// of each prover's code returns the slices that must be loaded by the verifiers.
    pub fn export_proof(&mut self) -> Vec<Fr> {
        let start = self.proof_start as usize;
        let result = self.proof_data[start..start + self.num_frs_written].to_vec();
        self.proof_start += self.num_frs_written as isize;
        self.num_frs_written = 0;
        result
    }

    /// Get the total size of proof_data.
    pub fn get_proof_size(&self) -> usize {
        self.proof_data.len()
    }

    /// Enable manifest recording.
    pub fn enable_manifest(&mut self) {
        self.use_manifest = true;
    }

    /// Get the manifest.
    pub fn get_manifest(&self) -> &TranscriptManifest {
        &self.manifest
    }

    /// Print the manifest.
    pub fn print(&self) {
        if !self.use_manifest {
            println!("Warning: manifest is not enabled!");
        }
        self.manifest.print();
    }

    // --- Prover methods ---

    /// Prover: Send an element to the verifier.
    ///
    /// Serializes the element to Fr fields, appends to proof_data,
    /// and adds to the current round's hash buffer.
    pub fn send_to_verifier<T: FieldSerializable>(&mut self, label: &str, element: &T) {
        let element_frs = element.serialize_to_frs();
        self.proof_data.extend_from_slice(&element_frs);
        self.num_frs_written += element_frs.len();
        self.add_element_frs_to_hash_buffer(label, &element_frs);
    }

    // --- Verifier methods ---

    /// Verifier: Receive an element from the prover.
    ///
    /// Reads the next T::NUM_FR elements from proof_data and adds them to the hash buffer.
    pub fn receive_from_prover<T: FieldSerializable>(&mut self, label: &str) -> T {
        let element_size = T::NUM_FR;
        assert!(
            self.num_frs_read + element_size <= self.proof_data.len(),
            "receive_from_prover: read past end of proof data (need {} more, have {})",
            element_size,
            self.proof_data.len() - self.num_frs_read
        );

        let element_frs = self.proof_data[self.num_frs_read..self.num_frs_read + element_size].to_vec();
        self.num_frs_read += element_size;

        self.add_element_frs_to_hash_buffer(label, &element_frs);

        T::deserialize_from_frs(&element_frs)
    }

    // --- Challenge generation ---

    /// Generate Fiat-Shamir challenges for the current round.
    ///
    /// Challenges are generated by iteratively hashing over the previous challenge.
    /// Each pair of challenges is 127 bits (split from a single hash output).
    pub fn get_challenges(&mut self, labels: &[&str]) -> Vec<Fr> {
        let num_challenges = labels.len();

        if self.use_manifest {
            for label in labels {
                self.manifest.add_challenge(self.round_number, label);
            }
        }

        let mut challenges = vec![Fr::zero(); num_challenges];

        // Generate challenges in pairs (each hash gives two 127-bit challenges)
        for i in 0..num_challenges / 2 {
            let challenge_buffer = self.get_next_duplex_challenge_buffer();
            challenges[2 * i] = challenge_buffer[0];
            challenges[2 * i + 1] = challenge_buffer[1];
        }
        // Handle odd number of challenges
        if num_challenges & 1 == 1 {
            let challenge_buffer = self.get_next_duplex_challenge_buffer();
            challenges[num_challenges - 1] = challenge_buffer[0];
        }

        self.round_number += 1;
        challenges
    }

    /// Get a single challenge.
    pub fn get_challenge(&mut self, label: &str) -> Fr {
        let labels = [label];
        let result = self.get_challenges(&labels);
        result[0]
    }

    /// Get a challenge and compute its dyadic powers [d, d^2, d^4, ..., d^(2^(n-1))].
    pub fn get_dyadic_powers_of_challenge(&mut self, label: &str, num_challenges: usize) -> Vec<Fr> {
        let challenge = self.get_challenge(label);
        let mut pows = vec![Fr::zero(); num_challenges];
        pows[0] = challenge;
        for i in 1..num_challenges {
            pows[i] = pows[i - 1].sqr();
        }
        pows
    }

    // --- Utility methods ---

    /// For testing: prover init with arbitrary data so challenges can be generated.
    pub fn prover_init_empty() -> Self {
        let mut transcript = Self::new();
        let init: u32 = 42;
        transcript.send_to_verifier("Init", &init);
        transcript
    }

    /// For testing: verifier init from proof data, consuming the init element.
    pub fn verifier_init_empty(prover: &mut Self) -> Self {
        let proof = prover.export_proof();
        let mut verifier = Self::from_proof(&proof);
        let _: Fr = verifier.receive_from_prover("Init");
        verifier
    }

    /// Convert a prover transcript to a verifier transcript.
    ///
    /// Expects that export_proof has already been called (num_frs_written == 0).
    pub fn convert_prover_to_verifier(prover: &Self) -> Self {
        assert_eq!(
            prover.num_frs_written, 0,
            "Expected num_frs_written to be 0 after export"
        );
        let mut verifier = Self {
            proof_data: prover.proof_data.clone(),
            is_first_challenge: prover.is_first_challenge,
            previous_challenge: prover.previous_challenge,
            current_round_data: prover.current_round_data.clone(),
            proof_start: 0,
            num_frs_written: 0,
            num_frs_read: prover.proof_start as usize,
            round_number: prover.round_number,
            use_manifest: prover.use_manifest,
            manifest: prover.manifest.clone(),
            _hasher: std::marker::PhantomData,
        };
        // Reset verifier-specific state
        verifier.proof_start = 0;
        verifier
    }

    /// Test utility: set proof parsing state for export after deserialization.
    pub fn test_set_proof_parsing_state(&mut self, start: isize, written: usize) {
        self.proof_start = start;
        self.num_frs_written = written;
    }

    /// Test utility: get proof_start for validation.
    pub fn test_get_proof_start(&self) -> isize {
        self.proof_start
    }

    /// Add an element to the hash buffer without writing to the proof data.
    ///
    /// Used when both prover and verifier already know the element (e.g.,
    /// commitment and opening pair in IPA). The element influences
    /// Fiat-Shamir challenges but is not part of the transmitted proof.
    ///
    /// Port of C++ `add_to_hash_buffer`.
    pub fn add_to_hash_buffer<T: FieldSerializable>(&mut self, label: &str, element: &T) {
        let element_frs = element.serialize_to_frs();
        self.add_element_frs_to_hash_buffer(label, &element_frs);
    }

    // --- Internal methods ---

    /// Add element field representations to the hash buffer and manifest.
    fn add_element_frs_to_hash_buffer(&mut self, label: &str, element_frs: &[Fr]) {
        if self.use_manifest {
            self.manifest
                .add_entry(self.round_number, label, element_frs.len());
        }
        self.current_round_data.extend_from_slice(element_frs);
    }

    /// Compute next challenge: c_next = H(Compress(c_prev || round_buffer))
    ///
    /// Hashes the previous challenge (if not first) concatenated with current round data.
    /// Returns two 127-bit challenges derived by splitting the hash output.
    fn get_next_duplex_challenge_buffer(&mut self) -> [Fr; 2] {
        let size_bump = if self.is_first_challenge { 0 } else { 1 };

        let mut full_buffer = Vec::with_capacity(self.current_round_data.len() + size_bump);

        if !self.is_first_challenge {
            full_buffer.push(self.previous_challenge);
        } else {
            assert!(
                !self.current_round_data.is_empty(),
                "Cannot generate first challenge with empty round data"
            );
            self.is_first_challenge = false;
        }

        full_buffer.extend_from_slice(&self.current_round_data);
        self.current_round_data.clear();

        // Hash the full buffer
        let new_challenge = H::hash(&full_buffer);
        let new_challenges = split_challenge(&new_challenge);

        // Update previous challenge for next call
        self.previous_challenge = new_challenge;

        new_challenges
    }
}

impl<H: TranscriptHasher> Default for BaseTranscript<H> {
    fn default() -> Self {
        Self::new()
    }
}
